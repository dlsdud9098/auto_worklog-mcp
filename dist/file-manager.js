import * as fs from 'fs/promises';
import * as path from 'path';
export class FileManager {
    config;
    todayLogsCache = new Map();
    constructor(config) {
        this.config = config;
    }
    getToday() {
        return new Date().toISOString().split('T')[0];
    }
    getYesterday() {
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        return yesterday.toISOString().split('T')[0];
    }
    async isFirstFileOfDay(project) {
        const today = this.getToday();
        const branch = this.config.gitBranch || 'main';
        const dirPath = path.join(this.config.paths.workLogBase, '개발일지', branch, today);
        try {
            const files = await fs.readdir(dirPath);
            const mdFiles = files.filter(f => f.endsWith('.md'));
            return mdFiles.length === 0;
        }
        catch (error) {
            return true;
        }
    }
    async getNextFileNumber(date, project) {
        const branch = this.config.gitBranch || 'main';
        const cacheKey = `${branch}/${date}`;
        if (this.todayLogsCache.has(cacheKey)) {
            const nextNum = (this.todayLogsCache.get(cacheKey) || 0) + 1;
            this.todayLogsCache.set(cacheKey, nextNum);
            return nextNum;
        }
        const dirPath = path.join(this.config.paths.workLogBase, '개발일지', branch, date);
        try {
            const files = await fs.readdir(dirPath);
            const mdFiles = files.filter(f => f.endsWith('.md'));
            let maxNumber = 0;
            for (const file of mdFiles) {
                const match = file.match(/^(\d{3})-/);
                if (match) {
                    const num = parseInt(match[1], 10);
                    if (num > maxNumber)
                        maxNumber = num;
                }
            }
            const nextNum = maxNumber + 1;
            this.todayLogsCache.set(cacheKey, nextNum);
            return nextNum;
        }
        catch (error) {
            this.todayLogsCache.set(cacheKey, 1);
            return 1;
        }
    }
    async saveConversation(content, summary, project) {
        const today = this.getToday();
        const branch = this.config.gitBranch || 'main';
        const fileNumber = await this.getNextFileNumber(today);
        const dirPath = path.join(this.config.paths.workLogBase, '개발일지', branch, today);
        await fs.mkdir(dirPath, { recursive: true });
        const paddedNumber = String(fileNumber).padStart(3, '0');
        const sanitizedSummary = summary.replace(/[^a-zA-Z0-9가-힣\s_]/g, '').substring(0, 50);
        const fileName = `${paddedNumber}-${sanitizedSummary}.md`;
        const filePath = path.join(dirPath, fileName);
        const fileContent = `# ${summary}

Date: ${today}
Branch: ${branch}
Log Number: ${paddedNumber}

---

${content}

---

*Generated by auto_worklog-mcp at ${new Date().toISOString()}*`;
        await fs.writeFile(filePath, fileContent, 'utf-8');
        return filePath;
    }
    async saveSummary(date, content, project) {
        const branch = this.config.gitBranch || 'main';
        const fileName = `${date}-요약.md`;
        const dirPath = path.join(this.config.paths.workLogBase, '요약', branch);
        const filePath = path.join(dirPath, fileName);
        await fs.mkdir(dirPath, { recursive: true });
        await fs.writeFile(filePath, content, 'utf-8');
        return filePath;
    }
    async listLogs(branch, project, date) {
        const logs = [];
        const workLogPath = path.join(this.config.paths.workLogBase, '개발일지');
        try {
            const branches = branch ? [branch] : await fs.readdir(workLogPath);
            for (const br of branches) {
                const branchPath = path.join(workLogPath, br);
                const dates = date ? [date] : await fs.readdir(branchPath);
                for (const dt of dates) {
                    if (!dt.match(/^\d{4}-\d{2}-\d{2}$/))
                        continue;
                    const datePath = path.join(branchPath, dt);
                    try {
                        const files = await fs.readdir(datePath);
                        for (const file of files) {
                            if (!file.endsWith('.md'))
                                continue;
                            const match = file.match(/^(\d{3})-(.+)\.md$/);
                            if (match) {
                                logs.push({
                                    branch: br,
                                    date: dt,
                                    fileName: file,
                                    filePath: path.join(datePath, file),
                                    summary: match[2]
                                });
                            }
                        }
                    }
                    catch (error) {
                        continue;
                    }
                }
            }
        }
        catch (error) {
            return [];
        }
        return logs.sort((a, b) => {
            const dateCompare = b.date.localeCompare(a.date);
            if (dateCompare !== 0)
                return dateCompare;
            return b.fileName.localeCompare(a.fileName);
        });
    }
    async getBranches() {
        try {
            const items = await fs.readdir(this.config.paths.workLogBase);
            const branches = [];
            for (const item of items) {
                const itemPath = path.join(this.config.paths.workLogBase, item);
                const stat = await fs.stat(itemPath);
                if (stat.isDirectory()) {
                    branches.push(item);
                }
            }
            return branches;
        }
        catch (error) {
            return [];
        }
    }
    async getProjects(branch) {
        try {
            const branchPath = path.join(this.config.paths.workLogBase, branch);
            const items = await fs.readdir(branchPath);
            const projects = [];
            for (const item of items) {
                const itemPath = path.join(branchPath, item);
                const stat = await fs.stat(itemPath);
                if (stat.isDirectory() && !item.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    projects.push(item);
                }
            }
            return projects;
        }
        catch (error) {
            return [];
        }
    }
    async getLastSummary(project) {
        try {
            const branch = this.config.gitBranch || 'main';
            const summaryPath = path.join(this.config.paths.workLogBase, '요약', branch);
            const files = await fs.readdir(summaryPath);
            const summaryFiles = files
                .filter(f => f.endsWith('-요약.md'))
                .sort((a, b) => b.localeCompare(a));
            if (summaryFiles.length === 0)
                return null;
            const lastSummaryPath = path.join(summaryPath, summaryFiles[0]);
            return await fs.readFile(lastSummaryPath, 'utf-8');
        }
        catch (error) {
            return null;
        }
    }
    async getLogsForDate(date, project) {
        const branch = this.config.gitBranch || 'main';
        const logs = await this.listLogs(branch, project, date);
        const contents = [];
        for (const log of logs) {
            try {
                const content = await fs.readFile(log.filePath, 'utf-8');
                contents.push(content);
            }
            catch (error) {
                console.error(`Failed to read log ${log.filePath}:`, error);
            }
        }
        return contents;
    }
}
//# sourceMappingURL=file-manager.js.map