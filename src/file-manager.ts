import * as fs from 'fs/promises';
import * as path from 'path';
import { Config } from './config.js';

export interface LogEntry {
  branch: string;
  date: string;
  fileName: string;
  filePath: string;
  summary: string;
}

export class FileManager {
  private config: Config;
  private todayLogsCache: Map<string, number> = new Map();

  constructor(config: Config) {
    this.config = config;
  }

  private getToday(): string {
    // 한국 시간으로 변환
    const now = new Date();
    const kstOffset = 9 * 60; // KST는 UTC+9
    const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000);
    const kstTime = new Date(utcTime + (kstOffset * 60000));
    return kstTime.toISOString().split('T')[0];
  }

  private getYesterday(): string {
    // 한국 시간 기준 어제
    const now = new Date();
    const kstOffset = 9 * 60; // KST는 UTC+9
    const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000);
    const kstTime = new Date(utcTime + (kstOffset * 60000));
    kstTime.setDate(kstTime.getDate() - 1);
    return kstTime.toISOString().split('T')[0];
  }

  private getKSTTimestamp(): string {
    // 한국 시간으로 타임스탬프 생성
    const now = new Date();
    const kstOffset = 9 * 60; // KST는 UTC+9
    const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000);
    const kstTime = new Date(utcTime + (kstOffset * 60000));
    return kstTime.toISOString().replace('Z', '+09:00');
  }

  async isFirstFileOfDay(project?: string): Promise<boolean> {
    const today = this.getToday();
    const branch = this.config.gitBranch || 'main';
    const dirPath = path.join(this.config.paths.workLogBase, '개발일지', branch, today);
    
    try {
      const files = await fs.readdir(dirPath);
      const mdFiles = files.filter(f => f.endsWith('.md'));
      return mdFiles.length === 0;
    } catch (error) {
      return true;
    }
  }

  async getNextFileNumber(date: string, project?: string): Promise<number> {
    const branch = this.config.gitBranch || 'main';
    const cacheKey = `${branch}/${date}`;
    
    if (this.todayLogsCache.has(cacheKey)) {
      const nextNum = (this.todayLogsCache.get(cacheKey) || 0) + 1;
      this.todayLogsCache.set(cacheKey, nextNum);
      return nextNum;
    }
    
    const dirPath = path.join(this.config.paths.workLogBase, '개발일지', branch, date);
    
    try {
      const files = await fs.readdir(dirPath);
      const mdFiles = files.filter(f => f.endsWith('.md'));
      
      let maxNumber = 0;
      for (const file of mdFiles) {
        const match = file.match(/^(\d{3})-/);
        if (match) {
          const num = parseInt(match[1], 10);
          if (num > maxNumber) maxNumber = num;
        }
      }
      
      const nextNum = maxNumber + 1;
      this.todayLogsCache.set(cacheKey, nextNum);
      return nextNum;
    } catch (error) {
      this.todayLogsCache.set(cacheKey, 1);
      return 1;
    }
  }

  async saveConversation(content: string, summary: string, project?: string): Promise<string> {
    const today = this.getToday();
    const branch = this.config.gitBranch || 'main';
    const fileNumber = await this.getNextFileNumber(today);
    
    const dirPath = path.join(this.config.paths.workLogBase, '개발일지', branch, today);
    await fs.mkdir(dirPath, { recursive: true });
    
    const paddedNumber = String(fileNumber).padStart(3, '0');
    const sanitizedSummary = summary.replace(/[^a-zA-Z0-9가-힣\s_]/g, '').substring(0, 50);
    const projectPrefix = project ? `[${project}]` : '';
    const fileName = `${paddedNumber}-${projectPrefix}${sanitizedSummary}.md`;
    const filePath = path.join(dirPath, fileName);
    
    const fileContent = `# ${summary}

Date: ${today}
Branch: ${branch}
Project: ${project || 'default'}
Log Number: ${paddedNumber}

---

${content}

---

*Generated by auto_worklog-mcp at ${this.getKSTTimestamp()}*`;
    
    await fs.writeFile(filePath, fileContent, 'utf-8');
    
    return filePath;
  }

  async saveSummary(date: string, content: string, project?: string): Promise<string> {
    const branch = this.config.gitBranch || 'main';
    const fileName = `${date}-요약.md`;
    const dirPath = path.join(this.config.paths.workLogBase, '요약', branch);
    const filePath = path.join(dirPath, fileName);
    
    await fs.mkdir(dirPath, { recursive: true });
    await fs.writeFile(filePath, content, 'utf-8');
    
    return filePath;
  }

  async listLogs(branch?: string, project?: string, date?: string): Promise<LogEntry[]> {
    const logs: LogEntry[] = [];
    const workLogPath = path.join(this.config.paths.workLogBase, '개발일지');
    
    try {
      const branches = branch ? [branch] : await fs.readdir(workLogPath);
      
      for (const br of branches) {
        const branchPath = path.join(workLogPath, br);
        const dates = date ? [date] : await fs.readdir(branchPath);
        
        for (const dt of dates) {
          if (!dt.match(/^\d{4}-\d{2}-\d{2}$/)) continue;
          
          const datePath = path.join(branchPath, dt);
          
          try {
            const files = await fs.readdir(datePath);
            
            for (const file of files) {
              if (!file.endsWith('.md')) continue;
              
              const match = file.match(/^(\d{3})-(.+)\.md$/);
              if (match) {
                logs.push({
                  branch: br,
                  date: dt,
                  fileName: file,
                  filePath: path.join(datePath, file),
                  summary: match[2]
                });
              }
            }
          } catch (error) {
            continue;
          }
        }
      }
    } catch (error) {
      return [];
    }
    
    return logs.sort((a, b) => {
      const dateCompare = b.date.localeCompare(a.date);
      if (dateCompare !== 0) return dateCompare;
      return b.fileName.localeCompare(a.fileName);
    });
  }

  private async getBranches(): Promise<string[]> {
    try {
      const items = await fs.readdir(this.config.paths.workLogBase);
      const branches: string[] = [];
      
      for (const item of items) {
        const itemPath = path.join(this.config.paths.workLogBase, item);
        const stat = await fs.stat(itemPath);
        if (stat.isDirectory()) {
          branches.push(item);
        }
      }
      
      return branches;
    } catch (error) {
      return [];
    }
  }

  private async getProjects(branch: string): Promise<string[]> {
    try {
      const branchPath = path.join(this.config.paths.workLogBase, branch);
      const items = await fs.readdir(branchPath);
      const projects: string[] = [];
      
      for (const item of items) {
        const itemPath = path.join(branchPath, item);
        const stat = await fs.stat(itemPath);
        if (stat.isDirectory() && !item.match(/^\d{4}-\d{2}-\d{2}$/)) {
          projects.push(item);
        }
      }
      
      return projects;
    } catch (error) {
      return [];
    }
  }

  async summaryExists(date: string): Promise<boolean> {
    try {
      const branch = this.config.gitBranch || 'main';
      const fileName = `${date}-요약.md`;
      const filePath = path.join(this.config.paths.workLogBase, '요약', branch, fileName);
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  async getLastSummary(project?: string): Promise<string | null> {
    try {
      const branch = this.config.gitBranch || 'main';
      const summaryPath = path.join(this.config.paths.workLogBase, '요약', branch);
      
      const files = await fs.readdir(summaryPath);
      const summaryFiles = files
        .filter(f => f.endsWith('-요약.md'))
        .sort((a, b) => b.localeCompare(a));
      
      if (summaryFiles.length === 0) return null;
      
      const lastSummaryPath = path.join(summaryPath, summaryFiles[0]);
      
      return await fs.readFile(lastSummaryPath, 'utf-8');
    } catch (error) {
      return null;
    }
  }

  async getLogsForDate(date: string, project?: string): Promise<string[]> {
    const branch = this.config.gitBranch || 'main';
    const logs = await this.listLogs(branch, project, date);
    const contents: string[] = [];
    
    for (const log of logs) {
      try {
        const content = await fs.readFile(log.filePath, 'utf-8');
        contents.push(content);
      } catch (error) {
        console.error(`Failed to read log ${log.filePath}:`, error);
      }
    }
    
    return contents;
  }
}